"""
This script converts a scene description CSV file (generated by scene_describe.py)
into audio markers within a silent WAV file, suitable for use in DAWs like Logic Pro.

Usage:
    python scene_description_to_audio_markers.py convert \
        --csv_input scene_output/scenes.csv \
        --output_audio scene_markers.wav \
        --verbose

    # Example using default output path (scene_output/scenes_markers.wav):
    python scene_description_to_audio_markers.py convert \
        --csv_input scene_output/scenes.csv \
        --verbose
"""

import os
import sys
import csv
import fire
import logging
import re
from typing import List, Dict, Any, Optional

# Import necessary components from logic_markers
# Assuming logic_markers.py is in the same directory or Python path
try:
    from logic_markers import Marker, LogicMarkerWriter, DEFAULT_SAMPLE_RATE, DEFAULT_SMPTE_FPS, DEFAULT_SMPTE_SUBFRAMES_PER_FRAME
except ImportError:
    print("Error: Could not import 'Marker' and 'LogicMarkerWriter' from 'logic_markers.py'.")
    print("Ensure 'logic_markers.py' is in the same directory or accessible in your PYTHONPATH.")
    sys.exit(1)

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s: [%(name)s.%(funcName)s] %(message)s')
# Get logger instance for the class
logger = logging.getLogger(f'{__name__}.SceneToAudioMarkerConverter')

class SceneToAudioMarkerConverter:
    """Converts scene description CSV data to Logic Pro markers in a silent WAV."""

    def __init__(self, verbose: bool = False):
        """
        Initializes the SceneToAudioMarkerConverter.

        Args:
            verbose: If True, sets logging level to DEBUG.
        """
        self._configure_logging(verbose)
        # Update logger name after configuration potentially changes level
        global logger
        logger = logging.getLogger(f'{self.__class__.__name__}')
        self.writer = LogicMarkerWriter(verbose=verbose) # Use the writer from logic_markers
        logger.debug("SceneToAudioMarkerConverter initialized.")

    def _configure_logging(self, verbose: bool):
        """Sets the logging level."""
        root_logger = logging.getLogger()
        if verbose:
            root_logger.setLevel(logging.DEBUG)
            class_logger = logging.getLogger(f'{self.__class__.__name__}')
            class_logger.debug("Verbose logging enabled.")
        else:
            root_logger.setLevel(logging.INFO)

    def _parse_scene_csv(self, csv_path: str) -> List[Dict[str, Any]]:
        """Parses the scene description CSV file."""
        logger.info(f"Parsing scene CSV file: {csv_path}")
        if not os.path.exists(csv_path):
            logger.error(f"CSV file not found: {csv_path}")
            raise FileNotFoundError(f"CSV file not found: {csv_path}")

        scenes = []
        try:
            with open(csv_path, 'r', newline='', encoding='utf-8') as csvfile:
                reader = csv.DictReader(csvfile)
                # Check required headers
                required_headers = ['Scene Number', 'Start Timecode', 'End Timecode', 'Scene Title']
                if not all(header in reader.fieldnames for header in required_headers):
                    missing = [h for h in required_headers if h not in reader.fieldnames]
                    error_msg = f"CSV file missing required headers: {missing}"
                    logger.error(error_msg)
                    raise ValueError(error_msg)

                for row in reader:
                    # Basic validation
                    if not all(row.get(h) for h in required_headers):
                        logger.warning(f"Skipping row due to missing values: {row}")
                        continue
                    scenes.append(row)
            logger.info(f"Successfully parsed {len(scenes)} scenes from {csv_path}")
            return scenes
        except Exception as e:
            logger.error(f"Error reading or parsing CSV file {csv_path}: {e}")
            raise

    def _parse_seconds_from_timecode(self, timecode: str) -> float:
        """Parses HH:MM:SS.mmm or HH:MM:SS:FF.SF timecode to total seconds."""
        # Try HH:MM:SS.mmm format first
        match_ms = re.match(r'(\d+):(\d+):(\d+)\.(\d+)', timecode)
        if match_ms:
            hours = int(match_ms.group(1))
            minutes = int(match_ms.group(2))
            seconds = int(match_ms.group(3))
            milliseconds = int(match_ms.group(4))
            total_seconds = (hours * 3600) + (minutes * 60) + seconds + (milliseconds / 1000.0)
            return total_seconds

        # Fallback to HH:MM:SS:FF.SF using Marker logic (but just for calculation)
        # This assumes the logic_markers defaults if FF.SF is encountered
        try:
            # Use Marker.from_smpte just to leverage its parsing logic if needed
            # We only need the position calculation relative to standard defaults
            temp_marker = Marker.from_smpte(0, timecode, "", DEFAULT_SAMPLE_RATE, DEFAULT_SMPTE_FPS, DEFAULT_SMPTE_SUBFRAMES_PER_FRAME)
            # Calculate seconds from its sample position interpretation
            total_seconds = temp_marker.position / DEFAULT_SAMPLE_RATE
            logger.debug(f"Parsed timecode {timecode} using SMPTE fallback, resulting in {total_seconds:.3f} seconds.")
            return total_seconds
        except ValueError:
            # If neither format matches, raise an error
            raise ValueError(f"Invalid timecode format: {timecode}. Expected HH:MM:SS.mmm or HH:MM:SS:FF.SF.")

    def _create_markers_from_scenes(self, scenes: List[Dict[str, Any]]) -> List[Marker]:
        """Converts parsed scene data into a list of Marker objects."""
        logger.info(f"Converting {len(scenes)} scenes to Marker objects.")
        markers = []
        used_ids = set()
        for scene in scenes:
            try:
                # Use Scene Number as ID, ensuring uniqueness if needed
                marker_id = int(scene['Scene Number'])
                if marker_id in used_ids:
                    logger.warning(f"Duplicate Scene Number ({marker_id}) found. Marker IDs should ideally be unique. Using it anyway.")
                used_ids.add(marker_id)

                start_timecode = scene['Start Timecode']
                # Construct label in the format: #. title: summary
                title = scene.get('Scene Title', '').strip()
                summary = scene.get('Scene Summary', '').strip()
                # Default label if both title and summary are empty
                if not title and not summary:
                    label = f"{marker_id}. Scene {marker_id}"
                else:
                    label = f"{marker_id}. {title}: {summary}"

                # Truncate label if necessary (DAWs often have limits)
                # label = label[:80]

                # Parse timecode manually and calculate sample position
                total_seconds = self._parse_seconds_from_timecode(start_timecode)
                position_samples = int(total_seconds * self.writer.sample_rate)

                # Create Marker directly with calculated position
                marker = Marker(
                    id=marker_id,
                    position=position_samples,
                    label=label
                )
                markers.append(marker)
                logger.debug(f"Created Marker: ID={marker.id}, Pos={marker.position} (from {start_timecode}), Label='{marker.label}'")
            except ValueError as e:
                logger.error(f"Skipping scene due to invalid data: {scene}. Error: {e}")
                continue # Skip markers that cannot be parsed
            except Exception as e:
                logger.error(f"Unexpected error creating marker for scene: {scene}. Error: {e}")
                continue

        # Sort markers by position as expected by the writer/Logic Pro
        markers.sort(key=lambda m: m.position)
        logger.info(f"Successfully created {len(markers)} Marker objects.")
        return markers

    def convert(self, csv_input: str, output_audio: Optional[str] = None,
                channels: int = 1, bit_depth: int = 16,
                sample_rate: int = DEFAULT_SAMPLE_RATE,
                buffer_seconds: float = 1.0):
        """
        Converts a scene description CSV to a silent WAV file with markers.

        Args:
            csv_input: Path to the input CSV file (e.g., scenes.csv).
            output_audio: Optional path to save the output WAV file. 
                          Defaults to <csv_input_basename>_markers.wav in the same directory.
            channels: Number of audio channels for the silent WAV (default: 1).
            bit_depth: Bit depth for the silent WAV (default: 16).
            sample_rate: Sample rate for the silent WAV (default: 48000).
            buffer_seconds: Extra silence duration (in seconds) after the last marker (default: 1.0).
        """
        # Determine output path
        if output_audio is None:
            input_dir, input_filename = os.path.split(csv_input)
            input_basename, _ = os.path.splitext(input_filename)
            default_output_filename = f"{input_basename}_markers.wav"
            output_audio = os.path.join(input_dir, default_output_filename)
            logger.info(f"Output audio path not specified, defaulting to: {output_audio}")
        else:
            logger.info(f"Using specified output audio path: {output_audio}")

        # Log final paths
        logger.info(f"Starting conversion: {csv_input} -> {output_audio}")

        # Update writer's config if defaults were overridden
        self.writer.sample_rate = sample_rate
        # TODO: Expose FPS and Subframes as CLI args if needed

        try:
            # 1. Parse the CSV
            scenes = self._parse_scene_csv(csv_input)
            if not scenes:
                logger.error("No valid scenes found in CSV. Aborting.")
                return # Exit if no scenes parsed

            # 2. Create Marker objects
            markers = self._create_markers_from_scenes(scenes)
            if not markers:
                logger.error("No valid markers could be created from scenes. Aborting.")
                return # Exit if no markers created

            # 3. Calculate required duration
            # Need the end time of the *last* scene to determine duration accurately
            # Use the end timecode from the last scene in the *original* CSV order
            try:
                last_scene_end_smpte = scenes[-1]['End Timecode']
                # Parse timecode manually and calculate sample position
                end_total_seconds = self._parse_seconds_from_timecode(last_scene_end_smpte)
                last_event_position = int(end_total_seconds * self.writer.sample_rate)
                # Create a temporary marker just to parse the end timecode
                # end_marker = Marker.from_smpte(0, last_scene_end_smpte, "", self.writer.sample_rate, self.writer.smpte_fps, self.writer.smpte_subframes)
                # last_event_position = end_marker.position
                logger.debug(f"Last scene ends at sample: {last_event_position} (from {last_scene_end_smpte})")
            except (ValueError, KeyError, IndexError) as e:
                 logger.warning(f"Could not determine end time from last scene: {e}. Using last marker position instead.")
                 last_event_position = markers[-1].position if markers else 0

            buffer_samples = int(buffer_seconds * self.writer.sample_rate)
            duration_samples = last_event_position + buffer_samples
            duration_seconds = duration_samples / self.writer.sample_rate
            logger.info(f"Last event at sample {last_event_position}.")
            logger.info(f"Calculated required duration: {duration_samples} samples ({duration_seconds:.2f}s including {buffer_seconds}s buffer).")

            # 4. Create silent WAV file
            logger.info(f"Creating silent WAV file: {output_audio}")
            self.writer._create_silent_wav(output_audio, duration_samples, channels, bit_depth)

            # 5. Write markers to the silent file
            # Use the output path as both input and output for the writer function,
            # as it handles the in-place modification correctly.
            logger.info(f"Writing {len(markers)} markers to {output_audio}")
            self.writer.write_markers_to_file(input_audio_path=output_audio, output_audio_path=output_audio, markers=markers)

            logger.info(f"Successfully created {output_audio} with {len(markers)} markers.")

        except FileNotFoundError as e:
            logger.error(f"Conversion failed: File not found - {e}")
            sys.exit(1)
        except (ValueError, TypeError, csv.Error) as e:
            logger.error(f"Conversion failed: Invalid file format or data - {e}")
            # Clean up potentially created but incomplete output file
            if os.path.exists(output_audio):
                try: os.remove(output_audio)
                except OSError: pass
            sys.exit(1)
        except Exception as e:
            logger.error(f"An unexpected error occurred during conversion: {type(e).__name__} - {e}", exc_info=logger.level == logging.DEBUG)
            # Clean up potentially created but incomplete output file
            if os.path.exists(output_audio):
                try: os.remove(output_audio)
                except OSError: pass
            sys.exit(1)

def main():
    """Main entry point for the script."""
    fire.Fire(SceneToAudioMarkerConverter)

if __name__ == '__main__':
    main()

